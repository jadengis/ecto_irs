defmodule EctoIRS.Schema do
  @moduledoc """
  `Ecto.Schema` extensions for auditing capabilities.

  This module provides the `audits/2` macro that automatically adds audit fields
  to your Ecto schemas for tracking who created or modified records.

  ## Usage

  First, add `use EctoIRS.Schema` to your schema module, then use the `audits/2`
  macro to generate audit fields:

      defmodule MyApp.Post do
        use Ecto.Schema
        use EctoIRS.Schema

        schema "posts" do
          field :title, :string
          field :content, :text
          
          # Generates :inserted_by and :updated_by associations
          audits MyApp.User
          
          timestamps()
        end
      end

  This will add `:inserted_by_id` and `:updated_by_id` fields to your schema,
  along with `:inserted_by` and `:updated_by` associations that reference the
  specified type.

  ## Custom Field Names

  You can customize the field names:

      defmodule MyApp.Post do
        use Ecto.Schema
        use EctoIRS.Schema

        schema "posts" do
          field :title, :string
          
          audits MyApp.User,
            inserted_by: :created_by,
            updated_by: :modified_by
        end
      end

  ## Disabling Fields

  You can disable either field by setting it to `false`:

      defmodule MyApp.Post do
        use Ecto.Schema
        use EctoIRS.Schema

        schema "posts" do
          field :title, :string
          
          # Only track who created, not who updated
          audits MyApp.User, updated_by: false
        end
      end

  ## Custom References

  If your referenced schema uses a custom primary key, specify it with the
  `:references` option:

      defmodule MyApp.Post do
        use Ecto.Schema
        use EctoIRS.Schema

        schema "posts" do
          field :title, :string
          
          audits MyApp.User, references: :user_id
        end
      end

  ## Autogeneration

  You can configure automatic population of audit fields using the
  `:autogenerate` option with an MFA tuple:

      defmodule MyApp.Post do
        use Ecto.Schema
        use EctoIRS.Schema

        schema "posts" do
          field :title, :string
          
          audits MyApp.User, autogenerate: {MyApp.Context, :current_user_id, []}
        end
      end

  ## Pre-configuration

  You can pre-configure audit options using the `@audits_opts` module attribute:

      defmodule MyApp.Post do
        use Ecto.Schema
        use EctoIRS.Schema

        @audits_opts [autogenerate: {MyApp.Context, :current_user_id, []}]

        schema "posts" do
          field :title, :string
          audits MyApp.User
        end
      end
  """

  @opts_schema [
    inserted_by: [
      type: {:or, [:atom, {:in, [false]}]},
      default: :inserted_by,
      doc: "the Ecto schema name of the field for insertion times or `false`"
    ],
    updated_by: [
      type: {:or, [:atom, {:in, [false]}]},
      default: :updated_by,
      doc: "the Ecto schema name of the field for update times or `false`"
    ],
    references: [
      type: :atom,
      doc: "the field on `type` the audits reference"
    ],
    autogenerate: [
      type: {:tuple, [:atom, :atom, {:list, :any}]},
      doc: "an MFA tuple used for generating both `inserted_by_id` and `updated_by_id`"
    ]
  ]

  @doc false
  defmacro __using__(_) do
    quote do
      import EctoIRS.Schema

      @audits_opts []
    end
  end

  @doc """
  Generates `:inserted_by` and `:updated_by` audit fields.

  The fields generated by this macro will automatically be set to
  the subject from the current context.

  ## Options

  #{NimbleOptions.docs(@opts_schema)}

  All options can be pre-configured by setting `@audits_opts`.
  """
  defmacro audits(type, opts \\ []) do
    opts_schema = @opts_schema

    quote bind_quoted: binding() do
      merged_opts = Keyword.merge(@audits_opts, opts)
      audits = NimbleOptions.validate!(merged_opts, opts_schema)

      autogen = audits[:autogenerate]

      inserted_by = audits[:inserted_by]
      updated_by = audits[:updated_by]
      opts = if references = audits[:references], do: [references: references], else: []

      if inserted_by do
        Ecto.Schema.belongs_to(inserted_by, type, opts)
      end

      if updated_by do
        Ecto.Schema.belongs_to(updated_by, type, opts)

        with {m, f, a} when is_atom(m) and is_atom(f) and is_list(a) <- autogen do
          Module.put_attribute(__MODULE__, :ecto_autoupdate, {[:"#{updated_by}_id"], autogen})
        end
      end

      with {m, f, a} when is_atom(m) and is_atom(f) and is_list(a) <- autogen,
           [_ | _] = fields <- Enum.filter([inserted_by, updated_by], & &1) do
        Module.put_attribute(
          __MODULE__,
          :ecto_autogenerate,
          {Enum.map(fields, &:"#{&1}_id"), autogen}
        )
      end

      :ok
    end
  end
end
